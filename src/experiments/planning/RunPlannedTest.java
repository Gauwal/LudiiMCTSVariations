package experiments.planning;

import experiments.catalog.GameCatalog;
import game.Game;
import mcts.MCTSVariations;
import other.AI;
import other.GameLoader;
import other.RankUtils;
import other.context.Context;
import other.move.Move;
import other.trial.Trial;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Runs exactly one row from a planned test CSV (produced by {@link GenerateTestPlan}).
 *
 * Intended to be launched from SLURM scripts generated by {@link GenerateSlurmScripts}.
 */
public final class RunPlannedTest
{
	private RunPlannedTest()
	{
		// utility
	}

	public static void main(final String[] args) throws Exception
	{
		final Args parsed = Args.parse(args);
		final PlannedTest test = PlannedTest.loadById(parsed.planPath, parsed.testId);
		if (test == null)
			throw new IllegalArgumentException("TestId not found in plan: " + parsed.testId);

		final Game game = GameLoader.loadGameFromName(test.gameName);
		if (game == null)
			throw new IllegalStateException("Unable to load game: " + test.gameName);

		if (game.players().count() != 2)
			throw new IllegalStateException("RunPlannedTest currently supports 2-player games only; found " + game.players().count());

		final Config baseline = new Config(test.baselineSelection, test.baselineSimulation, test.baselineBackprop, test.baselineFinalMove);
		final Config variant = new Config(test.variantSelection, test.variantSimulation, test.variantBackprop, test.variantFinalMove);

		final MatchStats stats = runMatchup(game, variant, baseline, test);
		writeSingleResult(parsed.outPath, test, stats);

		System.out.printf(
				Locale.ROOT,
				"Completed %s (%s) -> completed=%d/%d, wins=%d, losses=%d, draws=%d, failures=%d, avgMoves=%.1f%n",
				test.testId,
				test.gameName,
				stats.completedGames,
				stats.attemptedGames,
				stats.variantWins,
				stats.baselineWins,
				stats.draws,
				stats.failures,
				stats.averageMoves()
		);
	}

	private static MatchStats runMatchup(final Game game, final Config variant, final Config baseline, final PlannedTest test)
	{
		final MatchStats stats = new MatchStats();

		for (int gameIndex = 0; gameIndex < test.gamesPerMatchup; ++gameIndex)
		{
			stats.attemptedGames++;
			final boolean variantFirst = (gameIndex % 2 == 0);
			final Config p1 = variantFirst ? variant : baseline;
			final Config p2 = variantFirst ? baseline : variant;

			final GameOutcome outcome = playGame(game, p1, p2, test.moveTimeSeconds, test.maxMoves);
			if (!outcome.success)
			{
				stats.failures++;
				stats.lastError = outcome.errorSummary;
				continue;
			}

			stats.completedGames++;
			stats.totalMoves += outcome.numMoves;

			final double utilityP1 = outcome.utilities[1];
			final double utilityP2 = outcome.utilities[2];

			final int result;
			if (utilityP1 > utilityP2)
				result = 1;
			else if (utilityP2 > utilityP1)
				result = -1;
			else
				result = 0;

			if (result == 0)
			{
				stats.draws++;
			}
			else if (result > 0)
			{
				if (variantFirst)
					stats.variantWins++;
				else
					stats.baselineWins++;
			}
			else
			{
				if (variantFirst)
					stats.baselineWins++;
				else
					stats.variantWins++;
			}
		}

		return stats;
	}

	private static GameOutcome playGame(
			final Game game,
			final Config player1,
			final Config player2,
			final double moveTimeSeconds,
			final int maxMoves)
	{
		final Trial trial = new Trial(game);
		final Context context = new Context(game, trial);
		game.start(context);

		final AI[] agents = new AI[3];
		agents[1] = player1.instantiate();
		agents[2] = player2.instantiate();

		for (int p = 1; p <= 2; ++p)
			agents[p].initAI(game, p);

		Throwable failure = null;
		while (!context.trial().over() && failure == null)
		{
			if (maxMoves > 0 && context.trial().numMoves() >= maxMoves)
				break;

			final int mover = context.state().mover();
			final AI agent = agents[mover];
			final Move move;
			try
			{
				move = agent.selectAction(game, new Context(context), moveTimeSeconds, -1, -1);
			}
			catch (final Throwable ex)
			{
				failure = ex;
				break;
			}

			game.apply(context, move);
		}

		for (int p = 1; p <= 2; ++p)
		{
			try
			{
				agents[p].closeAI();
			}
			catch (final Throwable ignored)
			{
				// best effort
			}
		}

		if (failure != null)
			return GameOutcome.failure(failure);

		return GameOutcome.success(RankUtils.agentUtilities(context), context.trial().numMoves());
	}

	private static void writeSingleResult(final Path out, final PlannedTest test, final MatchStats stats) throws IOException
	{
		Files.createDirectories(out.toAbsolutePath().getParent());
		try (BufferedWriter bw = Files.newBufferedWriter(out, StandardCharsets.UTF_8))
		{
			bw.write("testId,gameName,component,baselineSelection,baselineSimulation,baselineBackprop,baselineFinalMove,variantSelection,variantSimulation,variantBackprop,variantFinalMove,moveTimeSeconds,gamesPerMatchup,maxMoves,requiresHeuristics,variantWins,baselineWins,draws,failures,completedGames,attemptedGames,averageMoves,lastError");
			bw.newLine();
			bw.write(String.format(
					Locale.ROOT,
					"%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%.6f,%d,%d,%d,%d,%d,%d,%d,%d,%d,%.4f,%s",
					escape(test.testId),
					escape(test.gameName),
					escape(test.component),
					escape(test.baselineSelection),
					escape(test.baselineSimulation),
					escape(test.baselineBackprop),
					escape(test.baselineFinalMove),
					escape(test.variantSelection),
					escape(test.variantSimulation),
					escape(test.variantBackprop),
					escape(test.variantFinalMove),
					test.moveTimeSeconds,
					test.gamesPerMatchup,
					test.maxMoves,
					test.requiresHeuristics,
					stats.variantWins,
					stats.baselineWins,
					stats.draws,
					stats.failures,
					stats.completedGames,
					stats.attemptedGames,
					stats.averageMoves(),
					escape(stats.lastError == null ? "" : stats.lastError)
			));
			bw.newLine();
		}
	}

	private static String escape(final String s)
	{
		if (s == null)
			return "";
		final String t = s.replace("\n", " ").replace("\r", " ").trim();
		if (t.contains(",") || t.contains("\"") || t.contains(" "))
			return "\"" + t.replace("\"", "\"\"") + "\"";
		return t;
	}

	private static final class Config
	{
		final String selection;
		final String simulation;
		final String backprop;
		final String finalMove;

		Config(final String selection, final String simulation, final String backprop, final String finalMove)
		{
			this.selection = selection;
			this.simulation = simulation;
			this.backprop = backprop;
			this.finalMove = finalMove;
		}

		AI instantiate()
		{
			return new MCTSVariations(selection, simulation, backprop, finalMove);
		}
	}

	private static final class MatchStats
	{
		int variantWins;
		int baselineWins;
		int draws;
		int totalMoves;
		int completedGames;
		int failures;
		int attemptedGames;
		String lastError;

		double averageMoves()
		{
			return completedGames == 0 ? 0.0 : (double) totalMoves / completedGames;
		}
	}

	private static final class GameOutcome
	{
		final boolean success;
		final double[] utilities;
		final int numMoves;
		final String errorSummary;

		private GameOutcome(final boolean success, final double[] utilities, final int numMoves, final String errorSummary)
		{
			this.success = success;
			this.utilities = utilities;
			this.numMoves = numMoves;
			this.errorSummary = errorSummary;
		}

		static GameOutcome success(final double[] utilities, final int numMoves)
		{
			return new GameOutcome(true, utilities, numMoves, null);
		}

		static GameOutcome failure(final Throwable t)
		{
			final String msg = t == null ? "unknown" : (t.getClass().getSimpleName() + ": " + String.valueOf(t.getMessage()));
			return new GameOutcome(false, new double[0], 0, msg);
		}
	}

	private static final class PlannedTest
	{
		final String testId;
		final String gameName;
		final String component;
		final String variantSelection;
		final String variantSimulation;
		final String variantBackprop;
		final String variantFinalMove;
		final String baselineSelection;
		final String baselineSimulation;
		final String baselineBackprop;
		final String baselineFinalMove;
		final double moveTimeSeconds;
		final int gamesPerMatchup;
		final int maxMoves;
		final int requiresHeuristics;

		PlannedTest(
				final String testId,
				final String gameName,
				final String component,
				final String variantSelection,
				final String variantSimulation,
				final String variantBackprop,
				final String variantFinalMove,
				final String baselineSelection,
				final String baselineSimulation,
				final String baselineBackprop,
				final String baselineFinalMove,
				final double moveTimeSeconds,
				final int gamesPerMatchup,
				final int maxMoves,
				final int requiresHeuristics)
		{
			this.testId = testId;
			this.gameName = gameName;
			this.component = component;
			this.variantSelection = variantSelection;
			this.variantSimulation = variantSimulation;
			this.variantBackprop = variantBackprop;
			this.variantFinalMove = variantFinalMove;
			this.baselineSelection = baselineSelection;
			this.baselineSimulation = baselineSimulation;
			this.baselineBackprop = baselineBackprop;
			this.baselineFinalMove = baselineFinalMove;
			this.moveTimeSeconds = moveTimeSeconds;
			this.gamesPerMatchup = gamesPerMatchup;
			this.maxMoves = maxMoves;
			this.requiresHeuristics = requiresHeuristics;
		}

		static PlannedTest loadById(final Path plan, final String testId) throws IOException
		{
			try (BufferedReader br = Files.newBufferedReader(plan, StandardCharsets.UTF_8))
			{
				final String headerLine = br.readLine();
				if (headerLine == null)
					return null;
				final List<String> header = Csv.parseLine(headerLine);
				final Map<String, Integer> idx = Csv.index(header);

				String line;
				while ((line = br.readLine()) != null)
				{
					if (line.trim().isEmpty())
						continue;
					final List<String> fields = Csv.parseLine(line);
					final String id = Csv.get(fields, idx, "testId");
					if (!id.equals(testId))
						continue;

					return new PlannedTest(
							id,
							Csv.get(fields, idx, "gameName"),
							Csv.get(fields, idx, "component"),
							Csv.get(fields, idx, "variantSelection"),
							Csv.get(fields, idx, "variantSimulation"),
							Csv.get(fields, idx, "variantBackprop"),
							Csv.get(fields, idx, "variantFinalMove"),
							Csv.get(fields, idx, "baselineSelection"),
							Csv.get(fields, idx, "baselineSimulation"),
							Csv.get(fields, idx, "baselineBackprop"),
							Csv.get(fields, idx, "baselineFinalMove"),
							Csv.getDouble(fields, idx, "moveTimeSeconds", 0.1),
							Csv.getInt(fields, idx, "gamesPerMatchup", 2),
							Csv.getInt(fields, idx, "maxMoves", 500),
							Csv.getInt(fields, idx, "requiresHeuristics", 0)
					);
				}
			}
			return null;
		}
	}

	private static final class Args
	{
		final Path planPath;
		final String testId;
		final Path outPath;

		private Args(final Path planPath, final String testId, final Path outPath)
		{
			this.planPath = planPath;
			this.testId = testId;
			this.outPath = outPath;
		}

		static Args parse(final String[] args)
		{
			Path plan = Paths.get("planned_tests.csv");
			String testId = null;
			Path out = Paths.get("out", "planned_results", "result.csv");

			for (int i = 0; i < args.length; i++)
			{
				final String a = args[i];
				if ("--plan".equalsIgnoreCase(a) && i + 1 < args.length)
					plan = Paths.get(args[++i]);
				else if (("--test".equalsIgnoreCase(a) || "--test-id".equalsIgnoreCase(a)) && i + 1 < args.length)
					testId = args[++i];
				else if ("--out".equalsIgnoreCase(a) && i + 1 < args.length)
					out = Paths.get(args[++i]);
			}

			if (testId == null || testId.trim().isEmpty())
				throw new IllegalArgumentException("Missing required arg: --test-id T123");

			return new Args(plan, testId, out);
		}
	}

	private static final class Csv
	{
		static List<String> parseLine(final String line)
		{
			final List<String> out = new ArrayList<>();
			if (line == null)
				return out;

			final StringBuilder current = new StringBuilder();
			boolean inQuotes = false;
			for (int i = 0; i < line.length(); i++)
			{
				final char ch = line.charAt(i);
				if (inQuotes)
				{
					if (ch == '"')
					{
						final boolean nextIsQuote = (i + 1 < line.length()) && (line.charAt(i + 1) == '"');
						if (nextIsQuote)
						{
							current.append('"');
							i++;
						}
						else
						{
							inQuotes = false;
						}
					}
					else
					{
						current.append(ch);
					}
				}
				else
				{
					if (ch == '"')
					{
						inQuotes = true;
					}
					else if (ch == ',')
					{
						out.add(current.toString());
						current.setLength(0);
					}
					else
					{
						current.append(ch);
					}
				}
			}
			out.add(current.toString());
			return out;
		}

		static Map<String, Integer> index(final List<String> header)
		{
			final Map<String, Integer> map = new HashMap<>();
			for (int i = 0; i < header.size(); i++)
				map.put(norm(header.get(i)), i);
			return map;
		}

		static String get(final List<String> fields, final Map<String, Integer> idx, final String col)
		{
			final Integer i = idx.get(norm(col));
			if (i == null || i < 0 || i >= fields.size())
				return "";
			return fields.get(i);
		}

		static int getInt(final List<String> fields, final Map<String, Integer> idx, final String col, final int def)
		{
			final String s = get(fields, idx, col);
			try
			{
				return Integer.parseInt(s.trim());
			}
			catch (final Exception ignored)
			{
				return def;
			}
		}

		static double getDouble(final List<String> fields, final Map<String, Integer> idx, final String col, final double def)
		{
			final String s = get(fields, idx, col);
			try
			{
				return Double.parseDouble(s.trim());
			}
			catch (final Exception ignored)
			{
				return def;
			}
		}

		private static String norm(final String s)
		{
			return s == null ? "" : s.trim().toLowerCase(Locale.ROOT);
		}
	}
}
